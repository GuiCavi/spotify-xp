import { spawn } from "child_process";
import fs from "fs";
import path from "path";

import arg from "arg";
import inquirer from "inquirer";

import { printer } from "./printer/printer";

const urlRegex = "^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$";

const envTemplate = (options) => `# This file is generated by sxp-cli.
# Only edit this file if you know what you're doing.
NODE_ENV=development
CLIENT_ID=${options.clientId}
CLIENT_SECRET=${options.clientSecret}
SPOTIFY_CALLBACK_URI=${options.callbackUrl}
`;

function parseArgumentsIntoOptions(rawArgs) {
  const args = arg(
    {
      "--client-id": String,
      "--client-secret": String,
      "--callback-url": String,
    },
    { argv: rawArgs.slice(3) }
  );

  return {
    clientId: args["--client-id"] || "",
    clientSecret: args["--client-secret"] || "",
    callbackUrl: args["--callback-url"] || "",
  };
}

async function promptForMissingOptions(options) {
  const questions = [];

  if (!options.clientId) {
    questions.push({
      type: "input",
      name: "clientId",
      message: printer.enter_client_id,
      validate: (input) => {
        if (!input) {
          return printer.provide_client_id;
        }

        const isValid = input.match(/^[a-zA-Z0-9-_]+$/);
        return isValid ? true : printer.invalid_client_id;
      },
    });
  }

  if (!options.clientSecret) {
    questions.push({
      type: "input",
      name: "clientSecret",
      message: printer.enter_client_secret,
      validate: (input) => {
        if (!input) {
          return printer.provide_client_secret;
        }

        const isValid = input.match(/^[a-zA-Z0-9-_]+$/);
        return isValid ? true : printer.invalid_client_secret;
      },
    });
  }

  if (!options.callbackUrl) {
    questions.push({
      type: "input",
      name: "callbackUrl",
      message: printer.enter_callback_url,
      validate: (value) => {
        if (!value) {
          return printer.provide_callback_url;
        }

        const regex = new RegExp(urlRegex, "i");

        if (value.match(regex)) {
          return true;
        }

        return printer.invalid_callback_url;
      },
    });
  }

  const answers = await inquirer.prompt(questions);

  return {
    ...options,
    ...answers,
  };
}

const checkDotEnvExists = () => {
  const dotEnvExists = fs.existsSync(path.join(process.cwd(), ".env"));

  return dotEnvExists;
};

const createEnvFile = async (options) => {
  if (checkDotEnvExists()) {
    fs.rmSync(path.join(process.cwd(), ".env"));
  }

  fs.writeFileSync(
    path.join(process.cwd(), ".env"),
    envTemplate(options)
  );

  await new Promise((res) => setTimeout(res, 1000));

  printer.dotenv_created();
};

const settingsFlow = async (args) => {
  printer.dotenv_overwrite();

  let options = parseArgumentsIntoOptions(args);
  options = await promptForMissingOptions(options);

  await createEnvFile(options);
};

const runFlow = async () => {
  if (!checkDotEnvExists()) {
    printer.dotenv_not_exists();
    return;
  }

  printer.run_command_help_text();

  const ls = spawn("yarn", ["start"]);

  ls.stdout.on("data", (data) => {
    console.log(`${data}`);
  });

  ls.stderr.on("data", (data) => {
    console.log(`${data}`);
  });

  ls.on("error", (error) => {
    console.log(`${error.message}`);
  });

  ls.on("close", (code) => {
    console.log(`child process exited with code ${code}`);
  });
};

const commands = {
  init: settingsFlow,
  run: runFlow,
};

export async function cli(args) {
  printer.start_cli();

  const cmd = args[2];

  if (!cmd || !(cmd in commands)) {
    if (!(cmd in commands)) printer.unknown_command(cmd);
    printer.commands_list(commands);

    return;
  }

  await commands[cmd](args);
}
